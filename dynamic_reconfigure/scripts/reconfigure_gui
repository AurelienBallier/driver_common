#! /usr/bin/env python
#***********************************************************
#* Software License Agreement (BSD License)
#*
#*  Copyright (c) 2009, Willow Garage, Inc.
#*  All rights reserved.
#*
#*  Redistribution and use in source and binary forms, with or without
#*  modification, are permitted provided that the following conditions
#*  are met:
#*
#*   * Redistributions of source code must retain the above copyright
#*     notice, this list of conditions and the following disclaimer.
#*   * Redistributions in binary form must reproduce the above
#*     copyright notice, this list of conditions and the following
#*     disclaimer in the documentation and/or other materials provided
#*     with the distribution.
#*   * Neither the name of the Willow Garage nor the names of its
#*     contributors may be used to endorse or promote products derived
#*     from this software without specific prior written permission.
#*
#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#*  POSSIBILITY OF SUCH DAMAGE.
#***********************************************************


import roslib; roslib.load_manifest('dynamic_reconfigure')
import rospy
import py_dynamic_reconfigure as dynamic_reconfigure
import threading
import wx
import unicodedata    
import math

#        self.combobox = wx.ComboBox(self, wx.ID_ANY, choices = dynamic_reconfigure.find_reconfigure_services(), 
#            style=wx.CB_READONLY)
#        self.sizer.Add(self.combobox, flag = wx.EXPAND)
#        self.Bind(wx.EVT_COMBOBOX, self.change)
#        self.SetSizer(self.sizer)
#        self.reconfigurator = None
#
#    def change(self, event):
#        node = unicodedata.normalize('NFKD', self.combobox.GetValue()).encode('ascii','ignore')
#        if self.reconfigurator:
#            self.sizer.Remove(self.reconfigurator)
#        self.reconfigurator = DynamicReconfigurePanel(self, node)
#        self.sizer.Add(self.reconfigurator, 1, wx.EXPAND|wx.ALL, 5)
#        self.sizer.Layout()
class DynamicReconfigureEnum(wx.ComboBox):
    def __init__(self, parent, name, val, enum):
        self.name = name
        self.to_value = dict((item['name'], item['value']) for item in enum)
        self.to_name = dict((item['value'], item['name']) for item in enum)
        wx.ComboBox.__init__(self, parent, wx.ID_ANY, self.to_name[val], choices = self.to_value.keys(), style=wx.CB_READONLY)
        self.old_value = val
        self.Bind(wx.EVT_COMBOBOX, self._update)

    def update_value(self, value):
        self.old_value = value
        try:
          new_name = self.to_name[value]
        except:
          new_name = ""
        self.SetValue(new_name)

    def _update(self, event):
        newvalue = self.to_value[self.GetValue()]
        if newvalue != self.old_value:
          self.GetParent().reconf.update_configuration({ self.name: newvalue })

class DynamicReconfigureBoolean(wx.CheckBox):
    def __init__(self, parent, name, value, min, max):
        self.name = name
        wx.CheckBox.__init__(self, parent, wx.ID_ANY)
        self.SetValue(value)
        self.old_value = value;
        self.Bind(wx.EVT_CHECKBOX, self._update)
                                         
    def update_value(self, value):
        self.old_value = value
        self.SetValue(value) 

    def _update(self, event):
        #print self.name, self.GetValue()
        new_value = self.GetValue()
        if new_value != self.old_value:
          self.GetParent().reconf.update_configuration({ self.name: newvalue })

class DynamicReconfigureString(wx.TextCtrl):
    def __init__(self, parent, name, value, min, max):
        self.name = name
        wx.TextCtrl.__init__(self, parent, wx.ID_ANY, style = wx.TE_PROCESS_ENTER)
        self.SetValue(value)
        self.Bind(wx.EVT_TEXT_ENTER, self._update)
        self.Bind(wx.EVT_KILL_FOCUS, self._update)
    
    def update_value(self, value):
        self.old_value = value
        wx.TextCtrl.SetValue(self, value)

    def _update(self, event):
        new_value = unicodedata.normalize('NFKD', self.GetValue()).encode('ascii','ignore')
        if self.old_value == new_value:
            return
        #print self.name, new_value, repr(new_value)
        self.GetParent().reconf.update_configuration({ self.name:new_value })
        #print rslt

class DynamicReconfigureInteger(wx.Panel):
    def __init__(self, parent, name, value, min, max):
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        self.name = name
        self.value = value
        self.min = min
        self.max = max
        
        sizer = wx.BoxSizer()
        self.slider = wx.Slider(self, wx.ID_ANY, minValue = self._slider_value(min), 
                maxValue = self._slider_value(max), style = wx.SL_AUTOTICKS | wx.SL_HORIZONTAL)
        sizer.Add(self.slider, wx.EXPAND)
        self.text = wx.TextCtrl(self, wx.ID_ANY, style = wx.TE_PROCESS_ENTER)
        sizer.Add(self.text)
        self.SetSizer(sizer)

        self.slider.Bind(wx.EVT_SCROLL, self._slider_update)
        self.text.Bind(wx.EVT_TEXT_ENTER, self._text_update)
        self.text.Bind(wx.EVT_KILL_FOCUS, self._text_update)

        self._update_widgets()

    def update_value(self, value):
        self.value = value
        self._update_widgets()

    def _change_value(self, new_value):
        if self.value == new_value:
            return
        self.GetParent().reconf.update_configuration({ self.name:new_value })
    
    def _update_widgets(self):
        #print "_update_widgets", self.value
        self.textvalue = str(self.value)
        self.text.SetValue(self.textvalue)
        self.slidervalue = self._slider_value(self.value)
        self.slider.SetValue(self.slidervalue)
        #print "set:", self.slidervalue, self.textvalue
    
    def _slider_value(self, val):
        return val
        
    def _inv_slider_value(self, val):
        return val

    def _text_value(self, val):
        return str(val)
    
    def _inv_text_value(self, val):
        return int(val)
    
    def _inv_bound_text_value(self, val):
        try:
            return min(max(self._inv_text_value(val), self.min), self.max)
        except Exception, e:
            #print e
            #print "_inv_text_value failed"
            return self.value

    def _slider_update(self, event):
        #print "get:", self.slider.GetValue()
        newslidervalue = self.slider.GetValue()
        if self.slidervalue == newslidervalue:
            return
        self._change_value(self._inv_slider_value(newslidervalue))

    def _text_update(self, event):
        newtextvalue = self.text.GetValue()
        if self.textvalue == newtextvalue:
            return
        newvalue = self._inv_bound_text_value(newtextvalue)
        #print "_text_update", self.text.GetValue(), self.min, self.max
        self._change_value(newvalue)

class DynamicReconfigureDouble(DynamicReconfigureInteger):
    def __init__(self, parent, name, value, min, max):
        self.func = lambda x:math.atan(x)
        self.ifunc = lambda x:math.tan(x)
        self.scale = (self.func(max) - self.func(min)) / 100
        self.offset = self.func(min)
        DynamicReconfigureInteger.__init__(self, parent, name, value, min, max)
    
    def _slider_value(self, val):
        return int(round((self.func(val) - self.offset) / self.scale))
        
    def _inv_slider_value(self, val):
        return self.ifunc(self.offset + val * self.scale)

    def _text_value(self, val):
        return str(val)

    def _inv_text_value(self, val):
        return float(val)

DynamicReconfigureWidget = {
        'bool':DynamicReconfigureBoolean,
        'int':DynamicReconfigureInteger,
        'double':DynamicReconfigureDouble,
        'str':DynamicReconfigureString,
        }
                    
class DynamicReconfigurePanel(wx.Panel):
    def __init__(self, parent, node):
        self.initialized = False
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        self.reconf = dynamic_reconfigure.DynamicReconfigureClient(node, config_callback = self._callback)
        config = self.reconf.get_configuration()
        descr = self.reconf.get_parameter_descriptions()
        
        sizer = wx.FlexGridSizer(0, 2)
        sizer.SetFlexibleDirection(wx.BOTH)
        sizer.AddGrowableCol(1, 1)
        flags = {
                'bool':wx.ALIGN_LEFT,
                'int':wx.EXPAND,
                'str':wx.EXPAND,
                'double':wx.EXPAND,
                }
        self.widgets = {}
        for param_descr in descr:
            name = param_descr['name']
            type = param_descr['type']
            val = config[name]
            min = param_descr['min']
            max = param_descr['max']
            #print param_descr['edit_method']
            sizer.Add(wx.StaticText(self, wx.ID_ANY, name+":"),1,
                    wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_RIGHT)
            try:
              enum = eval(param_descr['edit_method'])['enum']
              widget = DynamicReconfigureEnum(self, name, val, enum)
            except:
              widget = DynamicReconfigureWidget[type](self, name, val, min, max)
            sizer.Add(widget,0,flags[type])
            #sizer.Add(wx.StaticLine(self), 1, wx.EXPAND)
            #sizer.Add(wx.StaticLine(self), 1, wx.EXPAND)
            self.widgets[name] = widget

        self.SetSizer(sizer)
        self.initialized = True
        #self.Center()

    def _callback(self, config):
      # @todo There is a race condition at startup. We may miss some
      # updates that didn't get into the initial values.
      if self.initialized:
        for (name, widget) in self.widgets.iteritems():
          widget.update_value(config[name])

class DynamicReconfigureSelector(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        self.parent = parent
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.combobox = wx.ComboBox(self, wx.ID_ANY, choices = dynamic_reconfigure.find_reconfigure_services(), 
            style=wx.CB_READONLY)
        self.sizer.Add(self.combobox, flag = wx.EXPAND)
        self.Bind(wx.EVT_COMBOBOX, self.change)
        self.SetSizer(self.sizer)
        self.reconfigurator = None

    def change(self, event):
        node = unicodedata.normalize('NFKD', self.combobox.GetValue()).encode('ascii','ignore')
        if self.reconfigurator:
            self.sizer.Remove(self.reconfigurator)
        self.reconfigurator = DynamicReconfigurePanel(self, node)
        self.sizer.Add(self.reconfigurator, 1, wx.EXPAND|wx.ALL, 5)
        self.sizer.Layout()

class MainWindow(wx.Frame):
    def __init__(self, node = None):
        title = 'Reconfigure'
        if node:
            title = ' ' + node
        wx.Frame.__init__(self, None, wx.ID_ANY, title)
        self.filemenu = wx.Menu()
        self.filemenu.Append(wx.ID_EXIT, "E&xit"," Exit the program")
        self.menubar = wx.MenuBar()
        self.menubar.Append(self.filemenu,"&File")
        self.SetMenuBar(self.menubar)
        wx.EVT_MENU(self, wx.ID_EXIT, self.on_exit)
        
        self.timer = wx.Timer(self, wx.ID_ANY)
        self.Bind(wx.EVT_TIMER, self.on_timer, self.timer)
        self.timer.Start(1000, False) # on_timer will be called once per second.
        
        sizer = wx.BoxSizer(wx.VERTICAL)
        if node:
            sizer.Add(DynamicReconfigurePanel(self, node), 1, wx.EXPAND|wx.ALL, 5)
        else:
            sizer.Add(DynamicReconfigureSelector(self), 1, wx.EXPAND|wx.ALL, 5)
        self.SetSizer(sizer)
        #self.SetMaxSize(wx.Size(1500,1500))

    def on_exit(self, e):
        self.Close(True)
        self.Refresh()
            
    def on_error(self):
        self.Raise()

    def on_timer(self, event):
      #print rospy.is_shutdown()
      if rospy.is_shutdown():
        self.Close(True)
        self.Refresh()

if __name__ == '__main__':
    argv = rospy.myargv()
    if (len(argv) > 2):
        print "usage: reconfigure_gui.py <node_name>"
        exit(1)
    app = wx.PySimpleApp(clearSigInt = False)
    rospy.init_node("reconfigure_gui", anonymous=True)
    if len(argv) == 2:
        frame=MainWindow(argv[1])
    else:
        frame=MainWindow()
    frame.Show()
    try:
        ## @todo This try-except block is a temporary work around for
        # karmic, in which GetEffectiveMinSize apparently no longer exists.
        frame.SetMinSize(frame.GetEffectiveMinSize())
    except AttributeError:
        pass 
    try:
        app.MainLoop()
    except KeyboardInterrupt, e:
        pass
    print "exiting"
